---
layout: post
title: Umbra-mols -- Umbra-style molecules - part 2
description: ""
summary: ""
tags: [chembl, chemistry, rdkit, databases, duckdb, umbra]
---

After sharing [part 1], user dalke on hacker news gave me some helpful feedback and several new ideas
to explore.

One of the ideas is to get more out of the bytes than I currently am for the
bytes I'm using in the prefix.

## Abstract

- Analyzed the current version of the prefix in Umbra-style molecules, Umbra-mols,
  to get an idea of how often the short-circuit would not be triggered and deserialization
  would need to be done -- jump to that: [1](#jump-1)
- Explored alternative prefix encoding schemes -- jump to that: [2](#jump-2)
- Analyzed the max sizes of the easily accessible molecular attributes in chembl,
  pointing to an optimization -- jump to that: [3](#jump-3)
- Reduced the prefix size from 20 bytes to 10 bytes and achieved similar, possibly
  better performance (not thoroughly confirmed to be better)
- Tried a different scheme that creates only a 4 byte header, and tested the tradeoffs,
  which was not promising -- jump to that: [4](#jump-4)

Thanks again to dalke on hacker news for inspriation.

### Quick recap:

In [Umbra], the authors introduce a string encoding format (Umbra-style/German-style strings)
that enables a short-circuit to quickly return without more costly pointer
dereferencing which helps to speed up filtering in database systems.
If I understand correctly, the prefix alone is not supposed to be be sufficient for
distinguishing every record from another. Rather it is to rapidly filter out
records that simply cannot fulfill the condition, so that more expensive computations
can be avoided. Inspired by this and [RDKit] and [chemicalite], I applied some of the ideas from Umbra-strings
to molecules.

Currently, the prefix in "Umbra-mols" uses four easily accessible molecular attributes
to short-circuit in a comparison operation, and this leads to a big improvement
in exact match queries on molecular data in duckdb with an RDKit extension, see [part 1].

```
| 4 bytes - number of atoms | 4 bytes - number of bonds | 4 bytes - amw | 4 bytes - number of rings | 4 bytes - size of the binary molecule | n bytes - binary molecule |
```

The first 16 bytes makes up the prefix that is checked, and if two molecules
have different prefixes, the function can short circuit and avoid deserializing
the binary molecule for further checks to determine if the two molecules are the
"same" (depends on what the search is sensitive to).

In [Part 1] I find this method achieves ~26-60x speedup compared to an initial
implementation without this prefix.

### <a name="jump-1"></a>Taking a closer look at the "count prefix"

But how good is this prefix? How often do we hit the short-circuit, achieving
a speedup, and how often not?

I wanted to get some baseline measurements so that I
have something to compare it to when trying other ideas.

First, I want to see how many duplicate molecules are in the table to get a baseline.

There are 2,372,674 molecules in the table, 2,372,528 distinct by the chembl SMILES (146 duplicates),
and 2,372,527 distinct RDKit canonical SMILES (147 duplicates).

```sql
D select count(*) from molecule;
┌──────────────┐
│ count_star() │
│    int64     │
├──────────────┤
│      2372674 │
└──────────────┘
Run Time (s): real 0.001 user 0.004088 sys 0.000006

D select count(distinct(smiles)) from molecule;
┌────────────────────────┐
│ count(DISTINCT smiles) │
│         int64          │
├────────────────────────┤
│                2372528 │
└────────────────────────┘
Run Time (s): real 0.197 user 0.710163 sys 0.084169

D select count(distinct(mol)) from molecule;
┌─────────────────────┐
│ count(DISTINCT mol) │
│        int64        │
├─────────────────────┤
│             2372527 │
└─────────────────────┘
Run Time (s): real 0.652 user 2.213165 sys 0.457163
```

I used the Postgres RDKit extension to calculate the header values (number of atoms, etc.),
and then queried to find the counts of compound structures in chembl_33 that have the same number
of `num_rings`, `num_atoms`, `amw`, and `num_bonds`.

Below, I show the counts of replicated prefixes, collisions, in descending order.

There are ~245,562 records (nearly 10%) that have at least one other molecule that match its
prefix (and, not shown, ~28,000 that have at least 10 other molecules matching its prefix).
There are also some groups that have lots of replicates (>200, even one 511).

That means for many molecules it is not possible to resolve if they are different
by the prefix alone; they require the deserialization of the binary molecule to
answer that. Furthermore, for some molecules, if you hit one of these hot spots,
your query could need to deserialize 511 times.

```sql
D select * from (select num_rings, num_atoms, amw::integer, num_bonds, count(*) as count from molecule group by num_rings, num_atoms, amw::integer, num_bonds order by count desc) as g where g.count > 1;
┌───────────┬───────────┬──────────────────────┬───────────┬───────┐
│ num_rings │ num_atoms │ CAST(amw AS INTEGER) │ num_bonds │ count │
│   int32   │   int32   │        int32         │   int32   │ int64 │
├───────────┼───────────┼──────────────────────┼───────────┼───────┤
│         4 │       193 │                 1348 │        42 │   511 │
│         3 │        39 │                  308 │         4 │   330 │
│         3 │        42 │                  322 │         5 │   314 │
│         3 │        35 │                  282 │         3 │   311 │
│         3 │        31 │                  252 │         2 │   300 │
│         3 │        41 │                  310 │         4 │   294 │
│         3 │        36 │                  294 │         3 │   292 │
│         3 │        38 │                  296 │         4 │   292 │
│         3 │        32 │                  268 │         2 │   286 │
│         3 │        37 │                  280 │         3 │   280 │
│         3 │        36 │                  281 │         3 │   280 │
│         3 │        35 │                  278 │         3 │   279 │
│         3 │        37 │                  293 │         3 │   274 │
│         3 │        38 │                  309 │         4 │   272 │
│         3 │        34 │                  266 │         3 │   272 │
│         3 │        34 │                  266 │         2 │   271 │
│         3 │        47 │                  338 │         5 │   269 │
│         3 │        38 │                  296 │         3 │   266 │
│         3 │        41 │                  323 │         4 │   266 │
│         3 │        40 │                  311 │         4 │   262 │
│         · │         · │                   ·  │         · │     · │
│         · │         · │                   ·  │         · │     · │
│         · │         · │                   ·  │         · │     · │
│         5 │        76 │                  549 │         4 │     2 │
│         8 │        77 │                  636 │         6 │     2 │
│         4 │        30 │                  336 │         1 │     2 │
│         3 │        59 │                  476 │         6 │     2 │
│         5 │        52 │                  543 │         4 │     2 │
│         5 │        55 │                  571 │         4 │     2 │
│         3 │        71 │                  494 │         8 │     2 │
│         2 │        65 │                  444 │         3 │     2 │
│         3 │        55 │                  391 │         6 │     2 │
│         5 │        52 │                  465 │         8 │     2 │
│         4 │        43 │                  426 │         1 │     2 │
│         5 │        56 │                  379 │         7 │     2 │
│         2 │       103 │                  652 │        11 │     2 │
│         4 │        40 │                  401 │         6 │     2 │
│         4 │        46 │                  411 │         8 │     2 │
│         2 │        61 │                  400 │         7 │     2 │
│         2 │        19 │                  183 │         1 │     2 │
│         3 │        48 │                  290 │         3 │     2 │
│         3 │        49 │                  330 │         6 │     2 │
│         1 │        38 │                  324 │         4 │     2 │
├───────────┴───────────┴──────────────────────┴───────────┴───────┤
│ 245562 rows (40 shown)                                 5 columns │
└──────────────────────────────────────────────────────────────────┘
Run Time (s): real 0.094 user 0.312892 sys 0.017117

```

I picked a SMILES from this group, belonging to `molregno=1387483` which is
`CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=O)[C@H]1CCCN1C(=O)[C@H](N)CCCN=C(N)N)C(N)=O`
and ran this query with the Umbra-mol.

Note: truncated the output to fit better, so it says
40 shown, but I deleted some rows to not take up so much room.

<!-- D select molregno, canonical_smiles, mol, umbra_mol from molecule where amw::integer=1348 and num_rings=4 and num_atoms=193 and num_bonds=42; -->
<!-- ┌──────────┬──────────────────────┬──────────────────────┬────────────────────────────────────┐ -->
<!-- │ molregno │   canonical_smiles   │         mol          │             umbra_mol              │ -->
<!-- │  int64   │       varchar        │         mol          │              umbramol              │ -->
<!-- ├──────────┼──────────────────────┼──────────────────────┼────────────────────────────────────┤ -->
<!-- │  1387483 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(…  │ -->
<!-- │  1387484 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC…  │ -->
<!-- │  1387487 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC…  │ -->
<!-- │  1387482 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(…  │ -->
<!-- │  1387498 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(…  │ -->
<!-- │  1387485 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(…  │ -->
<!-- │  1387486 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(…  │ -->
<!-- │  2145176 │ CSCCC(NC(=O)C(CC(C…  │ CSCCC(NC(=O)C(CC(C…  │ CSCCC(NC(=O)C(CC(C)C)NC(=O)CNC(=…  │ -->
<!-- │    61009 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(…  │ -->
<!-- │      ·   │          ·           │          ·           │                 ·                  │ -->
<!-- │      ·   │          ·           │          ·           │                 ·                  │ -->
<!-- │      ·   │          ·           │          ·           │                 ·                  │ -->
<!-- │   233007 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC…  │ -->
<!-- │  1387488 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(…  │ -->
<!-- ├──────────┴──────────────────────┴──────────────────────┴────────────────────────────────────┤ -->
<!-- │ 511 rows (40 shown)                                                               4 columns │ -->
<!-- └─────────────────────────────────────────────────────────────────────────────────────────────┘ -->
<!-- Run Time (s): real 0.091 user 0.110002 sys 0.039836 -->

```sql

D select molregno, canonical_smiles, mol, umbra_mol from molecule where umbra_is_exact_match(umbra_mol,'CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=O)[C@H]1CCCN1C(=O)[C@H](N)CCCN=C(N)N)C(N)=O');
┌──────────┬──────────────────────┬──────────────────────┬────────────────────────────────────┐
│ molregno │   canonical_smiles   │         mol          │             umbra_mol              │
│  int64   │       varchar        │         mol          │              umbramol              │
├──────────┼──────────────────────┼──────────────────────┼────────────────────────────────────┤
│  1387483 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(…  │
│  1387484 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC…  │
│  1387487 │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C…  │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC…  │
│      ·   │          ·           │          ·           │                 ·                  │
│      ·   │          ·           │          ·           │                 ·                  │
│      ·   │          ·           │          ·           │                 ·                  │
├──────────┴──────────────────────┴──────────────────────┴────────────────────────────────────┤
│ 510 rows (40 shown)                                                               4 columns │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
Run Time (s): real 1.651 user 4.568367 sys 0.814046
```

Indeed, this query runs slower than, for example Query 1 from [part 1], and this is
insensitive to stereochemistry, so there are many hits. I logged
each time the short circuit was not triggered and deserialization of the binary molecule
was required, and I got 512 lines (not sure why there is an extra row though).
These results seem to support that the more deserialization we need to do in the query execution,
the slower it will be. But, it's still not bad -- the standard implementation which
deserializes the binary molecule takes 40 seconds. Note, there are several more
checks that happen with the RDKit molecule object, after deserializing, if the prefix cannot conclude that
the molecules are different.
So that means for each of these 511, there could be several steps of more expensive computation happening at each one.

Anyhow, seeing the number of collisions gives me some indication of how much filtering the prefix
of counts help in filtering molecules, and a place to work from to see if
alternative prefixes could be at least similar in its filtering capabilities or better, and ideally
smaller than the current 20 byte prefix.

<!-- ```sql -->
<!-- D SELECT count(distinct(rdkit_mol)) from molecule where amw::integer=1348 and num_atoms=193 and num_bonds=42 and num_rings=4 ; -->
<!-- ┌───────────────────────────┐ -->
<!-- │ count(DISTINCT rdkit_mol) │ -->
<!-- │           int64           │ -->
<!-- ├───────────────────────────┤ -->
<!-- │                       511 │ -->
<!-- └───────────────────────────┘ -->
<!-- Run Time (s): real 0.004 user 0.019251 sys 0.001141 -->
<!---->
<!-- D SELECT canonical_smiles from molecule where amw::integer=1348 and num_atoms=193 and num_bonds=42 and num_rings=4 ; -->
<!-- ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ -->
<!-- │                                                                            canonical_smiles                                                                             │ -->
<!-- │                                                                                 varchar                                                                                 │ -->
<!-- ├─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=O…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=O…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[C…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[C…  │ -->
<!-- │ CSCCC(NC(=O)C(CC(C)C)NC(=O)CNC(=O)C(Cc1ccccc1)NC(=O)C(Cc1ccccc1)NC(=O)C(CCC(N)=O)NC(=O)C(CCC(N)=O)NC(=O)C1CCCN1C(=O)C(CCCCN)NC(=O)C1CCCN1C(=O)C(N)CCCNC(=N)N)C(N)=O     │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[C@…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │                                                                                    ·                                                                                    │ -->
<!-- │                                                                                    ·                                                                                    │ -->
<!-- │                                                                                    ·                                                                                    │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=O…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)…  │ -->
<!-- │ CSCC[C@@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[C…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@@H](CC(C)C)NC(=O)CNC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@@H](CCC(N)=O)NC(=O)[C@@H]1CCCN1C(=O)[C@H](CCCCN)NC(=…  │ -->
<!-- │ CSCC[C@H](NC(=O)[C@H](CC(C)C)NC(=O)CNC(=O)[C@H](Cc1ccccc1)NC(=O)[C@@H](Cc1ccccc1)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H](CCC(N)=O)NC(=O)[C@H]1CCCN1C(=O)[C@H](CCCCN)NC(=O)[C…  │ -->
<!-- ├─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤ -->
<!-- │                                                                           511 rows (40 shown)                                                                           │ -->
<!-- └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ -->
<!-- Run Time (s): real 0.006 user 0.017807 sys 0.000000 -->
<!-- ``` -->

### <a name="jump-2"></a>Trying prefixes made from canonical smiles

Since comparing the SMILES between the two molecules is the final check in the
exact match algorithm ([part 1]), why make better use of the bytes in the prefix to store something that might
filter out more?

I don't believe the goal is to find a prefix that achieves perfect filtering,
like a hash function such as SHA-256 with incredibly low odds of collisions.
I think the main point is to try to achieve good-enough filtering via the short-circuit
check on the prefix, which will reduce the time the query needs to spend
in deserializing binary molecules, and to balance that with the cost of computing
and storing the data needed for this prefix.

I certainly could be overestimating the cost of computating a hash, or canonical SMILES.

On one extreme, we could put the SMILES all in the prefix.
That would give a very good filtering because there would be few collisions,
but we would have a variable length prefix that could become huge.
For example, this is a SMILES in chembl:
`CC(C)CCC[C@@](C)(O)[C@H]1CC[C@H]2[C@@H]3C[C@H](O[C@@H]4O[C@H](C)[C@@H](O)[C@H](O[C@@H]5OC[C@@H](O[C@@H]6O[C@H](C)[C@@H](O[C@@H]7OC[C@H](O)[C@H](O)[C@H]7O)[C@H](O)[C@H]6O[C@@H]6O[C@H](C)[C@H](O)[C@H](O)[C@H]6O)[C@H](O)[C@H]5O[C@@H]5O[C@H](C)[C@@H](O)[C@H](O)[C@H]5O)[C@H]4O)[C@H]4C[C@@H](OS(=O)(=O)O)CC[C@]4(C)C3=CC[C@@]21C`

At that point, it's probably better to not even bother with prefixes,
and just have the user create a `TEXT` column with the
canonoical SMILES and filter on that. Doing so would also take advantage of
duckdb's powerful string implementation as well as its compression methods.

But, this requires the user to have to add more data to their db for the SMILES
column, and perhaps require them to understand the internals of duckdb more -- that
it's very good with strings and compression.

Hash functions could be used on the SMILES string, but it's extra complexity in creating the prefix.
Again, perhaps I overestimate the cost of doing it.
The RegistrationHash from RDKit was one suggestion of an idea to explore, but I didn't find an implementation
of it in the C++ RDKit API. As for other hash functions, I don't want to bring
in other dependencies to calculate the hash, and I don't want to code up my own
low-collision hash.

Again, the goal is not to never get collisions in the prefix, it is just to get
a low enough number of conflicts that can speed up the process.

So, I explored taking slices of the canonicalSMILES and using that as a prefix.
I tried to see what I could do with 8 bytes.

I tried the following:

1. take the first 8 bytes of the canonical smiles and use that as a prefix
2. take the first 4 and last 4 bytes
3. split into three parts -- take the first 2 bytes, middle 4 bytes, and last 2 bytes
4. split into 4 equal parts of 2 bytes each

The idea of taking slices at different points of the SMILES is that hopefully
I could introduce some distinguishing features among similar SMILES so that I would not
get a collision.

Unfortunately, this had lots of collisions, and I abandoned the approach.
Besides, I'm no good at math, and perhaps someone more skilled in math could
figure out a clever sampling scheme to reduce the probability of a collision.

Here are the first 8 bytes:

```sql
D update molecule set prefix=left(mol::TEXT, 8);
D update molecule set prefix_two_split=concat(left(mol::TEXT, 4), right(mol::TEXT,4));
```

There are many molecules with the first 8 bytes. This probably won't make
things faster because the short-circuit won't help to filter as well.

```sql
D SELECT prefix, count(*) as c from molecule group by prefix order by c desc;
┌──────────┬────────┐
│  prefix  │   c    │
│ varchar  │ int64  │
├──────────┼────────┤
│ COc1ccc( │ 127784 │
│ COc1cccc │  54504 │
│ CCOC(=O) │  49159 │
│ CC(C)(C) │  30680 │
│ O=C(Nc1c │  30619 │
│ Cc1ccc(C │  28144 │
│ CCCCCCCC │  27587 │
│ COc1ccc2 │  25252 │
│    ·     │      · │
│    ·     │      · │
│    ·     │      · │
├──────────┴────────┤
│    21365 rows     │
│    (40 shown)     │
└───────────────────┘
Run Time (s): real 0.021 user 0.089599 sys 0.001947
```

Taking the first four and last four bytes still results in a lot of
molecules having the same prefix.

```sql
D SELECT prefix_two_split, count(*) as c from molecule group by prefix_two_split order by c desc;
┌──────────────────┬───────┐
│ prefix_two_split │   c   │
│     varchar      │ int64 │
├──────────────────┼───────┤
│ COc1)cc1         │ 73051 │
│ Cc1c)cc1         │ 46462 │
│ COc1c1OC         │ 40504 │
│ O=C()cc1         │ 28492 │
│ COc12)c1         │ 20259 │
│ O=C()CC1         │ 19656 │
│ Cc1c2)c1         │ 19023 │
│    ·             │     · │
│    ·             │     · │
│    ·             │     · │
├──────────────────┴───────┤
│  47074 rows (40 shown)   │
└──────────────────────────┘
Run Time (s): real 0.030 user 0.145595 sys 0.000979

```

A prefix constructed from taking the first 2 bytes, middle 4 bytes, and last 2 bytes
still has lots of replicates.

```sql
D update molecule SET prefix_three_split=concat(left(mol::TEXT, 2), substr(mol::TEXT, length(mol::TEXT)//2, 4) ,right(mol::TEXT,2));

D SELECT prefix_three_split, count(*) as c from molecule group by prefix_three_split order by c desc;
┌────────────────────┬───────┐
│ prefix_three_split │   c   │
│      varchar       │ int64 │
├────────────────────┼───────┤
│ CC(=O)c1           │  6794 │
│ CO(=O)c1           │  5983 │
│ CCC(=Oc1           │  4767 │
│ Cc(=O)c1           │  4606 │
│ O=ccccc1           │  4512 │
│ COC(=Oc1           │  3882 │
│ CCccc(c1           │  3692 │
│    ·               │     · │
│    ·               │     · │
│    ·               │     · │
├────────────────────┴───────┤
│   336588 rows (40 shown)   │
└────────────────────────────┘
Run Time (s): real 0.081 user 0.339158 sys 0.032252
```

Split into four equal parts 2 bytes each is not very good either.

```sql
D update molecule SET prefix_three_split=concat(left(mol::TEXT, 2), substr(mol::TEXT, (length(mol::TEXT)//2)//2, 2),substr(mol::TEXT, length(mol::TEXT)//2+(length(mol::TEXT)-length(mol::TEXT)//2)//2, 2) ,right(mol::TEXT,2));

D SELECT prefix_four_split, count(*) as c from molecule group by prefix_four_split order by c desc;
┌───────────────────┬───────┐
│ prefix_four_split │   c   │
│      varchar      │ int64 │
├───────────────────┼───────┤
│ CCccccc1          │  3105 │
│ O=ccccc1          │  2785 │
│ COc(ccc1          │  2062 │
│ O=ccccC1          │  1779 │
│ COccccc1          │  1706 │
│ CCc(ccc1          │  1537 │
│ COC(ccc1          │  1518 │
│ CO(=ccc1          │  1394 │
│ CO(Cccc1          │  1362 │
│ O=ccc1c1          │  1066 │
│    ·              │     · │
│    ·              │     · │
│    ·              │     · │
├───────────────────┴───────┤
│  599864 rows (40 shown)   │
└───────────────────────────┘
Run Time (s): real 0.116 user 0.454655 sys 0.051427
```

I also tried increasing the prefix to 12 bytes, still lower than the 20 I'm
currently using to see how things might change.
Increased to 12 bytes. 6 bytes from the front, 6 from the back. Not better.

```sql
D update molecule set prefix_12b_two_split=concat(left(mol::TEXT, 6), right(mol::TEXT,6));

D SELECT prefix_12b_two_split, count(*) as c from molecule group by prefix_12b_two_split order by c desc;
┌──────────────────────┬───────┐
│ prefix_12b_two_split │   c   │
│       varchar        │ int64 │
├──────────────────────┼───────┤
│ COc1cc)cc1OC         │ 18373 │
│ COc1ccc2)cc1         │ 15665 │
│ COc1ccC)c1OC         │ 13882 │
│ COc1ccC2)cc1         │  9836 │
│ Cc1cccc2)cc1         │  9437 │
│ COc1cc(OC)c1         │  8243 │
│ COc1cc=O)cc1         │  7534 │
│ COc1ccn2)cc1         │  6396 │
│ Cc1cccC2)cc1         │  5658 │
│      ·               │     · │
│      ·               │     · │
│      ·               │     · │
├──────────────────────┴───────┤
│    251328 rows (40 shown)    │
└──────────────────────────────┘
Run Time (s): real 0.059 user 0.265381 sys 0.021503
```

At this point, I felt like I was trying to brute-force a hash function and I was
feeling pretty dumb about this. So I stopped with this approach.

### <a name="jump-3"></a>Can we squeeze the "count prefix" into smaller number of bytes?

The prefix currently consists of number of atoms, number of rings, number of bonds, amw, and the
size of the binary molecule in bytes.

I took a look at the max number of each count in chembl to get an idea of how big
of an int the prefix should support.

<!-- Even if we go over the max, it may be ok to just -->
<!-- cap that prefix value to the max. Even if the prefix only supports -->
<!-- a max value of `n` and we have a molecule of `n+m` where m > 0, as long as the -->
<!-- value of `n` is big enough such that not too many molecules are over the limit, -->
<!-- it could still serve as a good filter. -->

```sql
D select max(num_atoms), max(num_rings), max(num_bonds), max(amw::integer) from molecule;
┌────────────────┬────────────────┬────────────────┬───────────────────────────┐
│ max(num_atoms) │ max(num_rings) │ max(num_bonds) │ max(CAST(amw AS INTEGER)) │
│     int32      │     int32      │     int32      │           int32           │
├────────────────┼────────────────┼────────────────┼───────────────────────────┤
│           1398 │             85 │            360 │                     12546 │
└────────────────┴────────────────┴────────────────┴───────────────────────────┘
Run Time (s): real 0.012 user 0.054625 sys 0.001450

# and the max binary molecule size. switched to RDKit postgres to calculate this value

chembl_33=# select max(octet_length(mol_to_pkl(rdkit_mol))) from compound_structures;
  max
-------
 15762
(1 row)

```

The numbers are not very big. Even for the really big molecule with an amw of 12,546 (which
after rendering and seeing the graph structure from the SMILES, I'm not sure
it could even be considered a small molecule, perhaps more like a polymer),
it's much smaller than what can fit in 2 bytes which can handle a range of 0 to 65,535.

2 bytes looks like it should handle any of the above values from
a small molecule. By using 2 bytes for each value, we should be able to get the prefix down from
20 bytes to 10 bytes (currently each value is represented as a 4 byte unsigned int)

I switched the implementation to a 2 byte unsigned int for each value in the
prefix.

```
10 byte prefix: 06 00 06 00 4e 00 01 00 83 00
binary molecule: ef be ad de 00 00 00 00 0f 00 00 00 00 00 00 00 00 00 00 00 06 00 00 00 06 00 00 00 80 01 06 40 68 00 00 00 03 03 01 06 40 68 00 00 00 03 03 01 06 40 68 00 00 00 03 03 01 06 40 68 00 00 00 03 03 01 06 40 68 00 00 00 03 03 01 06 40 68 00 00 00 03 03 01 0b 00 01 68 0c 01 02 68 0c 02 03 68 0c 03 04 68 0c 04 05 68 0c 05 00 68 0c 14 01 00 00 00 06 00 05 04 03 02 01 17 04 00 00 00 00 00 00 00 16
```

Then I tested it on the queries I did in my previous post.
Not a well thought out benchmark, just something I did before and could roughly compare to.
I may have had some background YouTube running while running queries.

The 10 byte prefix performs similarly as the larger 20 byte prefix, maybe even
a little better (but I did not confirm with much more thorough testing).

| Query | Standard method (s) | Umbra-mol 20-byte prefix (s) | Umbra-mol 10-byte prefix (s) |
| :---- | :------------------ | :--------------------------- | :--------------------------- |
| 1     | 17.238              | 0.496                        | 0.311                        |
| 2     | 12.555              | 0.473                        | 0.273                        |
| 3     | 22.196              | 0.364                        | 0.592                        |
| 4     | 12.245              | 0.359                        | 0.350                        |

### Can we improve this with information that we already have in the header, like the binary molecule size?

We also have the binary molecule size in the header, but currently
do not consider it when computing exact match. Here, I used the RDKit
Postgres extension to get the length of the binary molecule in bytes.
I then checked if we would see fewer collisions if we consider the binary size along with the other values.

The result of the query is here:

```sql
 num_rings | num_atoms | amw  | num_bonds | bmolsize | count
-----------+-----------+------+-----------+----------+-------
         4 |       193 | 1348 |        42 |     1197 |   510
         3 |        31 |  252 |         2 |      320 |    90
         3 |        41 |  323 |         4 |      378 |    87
         3 |        32 |  251 |         2 |      321 |    81
         3 |        32 |  268 |         2 |      333 |    81
         3 |        33 |  267 |         3 |      332 |    73
         5 |        44 |  386 |         2 |      450 |    73
         3 |        35 |  265 |         3 |      332 |    72
         3 |        40 |  311 |         5 |      363 |    71
         2 |        41 |  314 |         6 |      358 |    70
```

It looks like it can reduce some of the collisions that were in the 200-300
replicate name down to < 100. I think it would improve the short-circuit hits,
and speed up the queries.

However, I'm not sure how reliable it would be to include the
binary molecule size in consideration because if RDKit changes its format,
the binary molecule size could change even though the molecule stays the same.
The other values values are intrinsic to the molecule, but the binary format is not.

This could lead to false negatives if the binary molecule format
changes and we use the new version while we have something stored in the database from a previous format.
If the new format has a different size, the short-circuit code will detect that the
sizes are different, and conclude the molecules are not the same, when they could be.

So, I won't use that in the prefix.

I also considered putting a short SMILES into the prefix and that can indeed help
reduce collisions, but now I might increase the cost of creating the
prefix because I would need to calculate the SMILES to get to the prefix, and I would
need to also increase the header size to accomadate the SMILES prefix.
I decided not to pursue that route.

```sql

D select * from (select num_rings,num_atoms, amw::integer, num_bonds,prefix, count(*) as count from molecule group by num_rings, num_atoms, amw::integer, num_bonds, prefix order by count desc) as g where g.count > 1;
┌───────────┬───────────┬──────────────────────┬───────────┬──────────┬───────┐
│ num_rings │ num_atoms │ CAST(amw AS INTEGER) │ num_bonds │  prefix  │ count │
│   int32   │   int32   │        int32         │   int32   │ varchar  │ int64 │
├───────────┼───────────┼──────────────────────┼───────────┼──────────┼───────┤
│         4 │       193 │                 1348 │        42 │ CSCC[C@H │   509 │
│         3 │        39 │                  308 │         4 │ COc1ccc( │    70 │
│         3 │        35 │                  282 │         3 │ COc1ccc( │    58 │
│         3 │        38 │                  296 │         4 │ COc1ccc( │    55 │
│         2 │        41 │                  314 │         6 │ COc1ccc( │    52 │
│         3 │        38 │                  309 │         4 │ COc1ccc( │    52 │
│         3 │        40 │                  311 │         5 │ COc1ccc( │    52 │
│         3 │        40 │                  324 │         5 │ COc1ccc( │    51 │
│         3 │        46 │                  356 │         6 │ COc1ccc( │    49 │
│         2 │        37 │                  284 │         5 │ COc1ccc( │    49 │
│         3 │        36 │                  281 │         3 │ COc1ccc( │    49 │
│         3 │        39 │                  312 │         4 │ COc1ccc( │    48 │
│         4 │        49 │                  388 │         5 │ COc1ccc( │    47 │
│         3 │       110 │                  623 │        25 │ CCCCCCCC │    47 │
│         3 │        38 │                  248 │         0 │ C=C1C(=O │    45 │

```

### <a name="jump-4"></a> Squashed prefix: less space but more collisions

Just to see what would happen if we did something more drastic with the prefix,
I tried to squash all the counts into one value for the prefix in order
to shrink its size. I wondered how would that affect collisions and performance on the examples
I did so far.

To do this, I just summed the values of the fields, and then stored it in a single
2 byte value. This would make a header of 4 bytes (the summed values, and the binary
molecule size which is used for deserialization).

We can see that there will be a big increase in conflicts, but let's see how
it affects the execution time.

```sql
D select * from (select (num_rings+num_atoms+amw::integer+num_bonds) as ra, count(*) as count from molecule group by ra order by count desc) as g where g.count > 1;
┌───────┬───────┐
│  ra   │ count │
│ int32 │ int64 │
├───────┼───────┤
│   389 │  9192 │
│   393 │  8946 │
│   406 │  8808 │
│   424 │  8769 │
│   402 │  8758 │
│   407 │  8641 │
│   394 │  8633 │
│   411 │  8612 │
│   397 │  8589 │
│   398 │  8572 │
│   380 │  8544 │
│   376 │  8482 │
│   385 │  8362 │
│   429 │  8357 │
│   415 │  8353 │
│   384 │  8349 │
│   388 │  8254 │
```

I ran the queries with this 4-byte "squashed" prefix from my examples.
The squashed prefix is about ~1.7-2x as slow in Query 1 as the non-squashed
prefix. I also logged to a file whenever there was a prefix that was a match and
thus deserialization of the binary molecule was necesssary.
I found that the short circuit was not triggered 3,121 times as opposed to 487
with the separated values prefix (~6.4x more deserialization).

| Query | Standard method (s) | Umbra-mol 20-byte prefix (s) | Umbra-mol 10-byte prefix (s) | Umbra-mol squashed 4-byte prefix (s) |
| :---- | :------------------ | :--------------------------- | :--------------------------- | :----------------------------------- |
| 1     | 17.238              | 0.496                        | 0.311                        | 0.889                                |
| 2     | 12.555              | 0.473                        | 0.273                        | 0.493                                |
| 3     | 22.196              | 0.364                        | 0.592                        | 1.735                                |
| 4     | 12.245              | 0.359                        | 0.350                        | 0.900                                |

So the trend is full deserialization is really slow (standard method), squashing things
down to save on space is much faster than the standard, but also noticeably slower than the
full-separated prefix (20 & 10 byte versions), due to more collisions which means
more deserialization.

### Conclusions so far

- Analysis of the max values of the counts used in the prefix revealed that 2 bytes
  is probably sufficient, forming a 10 byte prefix instead of the initial implementation
  with a 20 byte prefix
- The 10 byte prefix performs similarly to the 20-byte prefix
- Trying to store SMILES slices in the prefix resulted in many collisions
- Collisions cause the short-circuit not to kick in, and requires falling back
  to the deserialization of the binary molecule more, and this incurs
  noticeable increase in query execution time

[chemicalite]: https://github.com/rvianello/chemicalite
[RDKit]: https://rdkit.org/docs/GettingStartedInC++.html
[part 1]: https://bodowd.github.io/2024/07/23/umbra-style-molecules
[Umbra]: https://db.in.tum.de/~freitag/papers/p29-neumann-cidr20.pdf
